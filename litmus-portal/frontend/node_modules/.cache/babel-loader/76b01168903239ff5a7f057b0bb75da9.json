{"ast":null,"code":"export function identityMatrix() {\n  return {\n    scaleX: 1,\n    scaleY: 1,\n    translateX: 0,\n    translateY: 0,\n    skewX: 0,\n    skewY: 0\n  };\n}\nexport function createMatrix(_ref) {\n  var _ref$scaleX = _ref.scaleX,\n      scaleX = _ref$scaleX === void 0 ? 1 : _ref$scaleX,\n      _ref$scaleY = _ref.scaleY,\n      scaleY = _ref$scaleY === void 0 ? 1 : _ref$scaleY,\n      _ref$translateX = _ref.translateX,\n      translateX = _ref$translateX === void 0 ? 0 : _ref$translateX,\n      _ref$translateY = _ref.translateY,\n      translateY = _ref$translateY === void 0 ? 0 : _ref$translateY,\n      _ref$skewX = _ref.skewX,\n      skewX = _ref$skewX === void 0 ? 0 : _ref$skewX,\n      _ref$skewY = _ref.skewY,\n      skewY = _ref$skewY === void 0 ? 0 : _ref$skewY;\n  return {\n    scaleX: scaleX,\n    scaleY: scaleY,\n    translateX: translateX,\n    translateY: translateY,\n    skewX: skewX,\n    skewY: skewY\n  };\n}\nexport function inverseMatrix(_ref2) {\n  var scaleX = _ref2.scaleX,\n      scaleY = _ref2.scaleY,\n      translateX = _ref2.translateX,\n      translateY = _ref2.translateY,\n      skewX = _ref2.skewX,\n      skewY = _ref2.skewY;\n  var denominator = scaleX * scaleY - skewY * skewX;\n  return {\n    scaleX: scaleY / denominator,\n    scaleY: scaleX / denominator,\n    translateX: (scaleY * translateX - skewX * translateY) / -denominator,\n    translateY: (skewY * translateX - scaleX * translateY) / denominator,\n    skewX: skewX / -denominator,\n    skewY: skewY / -denominator\n  };\n}\nexport function applyMatrixToPoint(matrix, _ref3) {\n  var x = _ref3.x,\n      y = _ref3.y;\n  return {\n    x: matrix.scaleX * x + matrix.skewX * y + matrix.translateX,\n    y: matrix.skewY * x + matrix.scaleY * y + matrix.translateY\n  };\n}\nexport function applyInverseMatrixToPoint(matrix, _ref4) {\n  var x = _ref4.x,\n      y = _ref4.y;\n  return applyMatrixToPoint(inverseMatrix(matrix), {\n    x: x,\n    y: y\n  });\n}\nexport function scaleMatrix(scaleX, maybeScaleY) {\n  if (maybeScaleY === void 0) {\n    maybeScaleY = undefined;\n  }\n\n  var scaleY = maybeScaleY || scaleX;\n  return createMatrix({\n    scaleX: scaleX,\n    scaleY: scaleY\n  });\n}\nexport function translateMatrix(translateX, translateY) {\n  return createMatrix({\n    translateX: translateX,\n    translateY: translateY\n  });\n}\nexport function multiplyMatrices(matrix1, matrix2) {\n  return {\n    scaleX: matrix1.scaleX * matrix2.scaleX + matrix1.skewX * matrix2.skewY,\n    scaleY: matrix1.skewY * matrix2.skewX + matrix1.scaleY * matrix2.scaleY,\n    translateX: matrix1.scaleX * matrix2.translateX + matrix1.skewX * matrix2.translateY + matrix1.translateX,\n    translateY: matrix1.skewY * matrix2.translateX + matrix1.scaleY * matrix2.translateY + matrix1.translateY,\n    skewX: matrix1.scaleX * matrix2.skewX + matrix1.skewX * matrix2.scaleY,\n    skewY: matrix1.skewY * matrix2.scaleX + matrix1.scaleY * matrix2.skewY\n  };\n}\nexport function composeMatrices() {\n  for (var _len = arguments.length, matrices = new Array(_len), _key = 0; _key < _len; _key++) {\n    matrices[_key] = arguments[_key];\n  }\n\n  switch (matrices.length) {\n    case 0:\n      throw new Error('composeMatrices() requires arguments: was called with no args');\n\n    case 1:\n      return matrices[0];\n\n    case 2:\n      return multiplyMatrices(matrices[0], matrices[1]);\n\n    default:\n      {\n        var matrix1 = matrices[0],\n            matrix2 = matrices[1],\n            restMatrices = matrices.slice(2);\n        var matrix = multiplyMatrices(matrix1, matrix2);\n        return composeMatrices.apply(void 0, [matrix].concat(restMatrices));\n      }\n  }\n}","map":{"version":3,"sources":["/home/vedant/go/src/github.com/litmus/litmus-portal/frontend/node_modules/@visx/zoom/esm/util/matrix.js"],"names":["identityMatrix","scaleX","scaleY","translateX","translateY","skewX","skewY","createMatrix","_ref","_ref$scaleX","_ref$scaleY","_ref$translateX","_ref$translateY","_ref$skewX","_ref$skewY","inverseMatrix","_ref2","denominator","applyMatrixToPoint","matrix","_ref3","x","y","applyInverseMatrixToPoint","_ref4","scaleMatrix","maybeScaleY","undefined","translateMatrix","multiplyMatrices","matrix1","matrix2","composeMatrices","_len","arguments","length","matrices","Array","_key","Error","restMatrices","slice","apply","concat"],"mappings":"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","sourcesContent":["export function identityMatrix() {\n  return {\n    scaleX: 1,\n    scaleY: 1,\n    translateX: 0,\n    translateY: 0,\n    skewX: 0,\n    skewY: 0\n  };\n}\nexport function createMatrix(_ref) {\n  var _ref$scaleX = _ref.scaleX,\n      scaleX = _ref$scaleX === void 0 ? 1 : _ref$scaleX,\n      _ref$scaleY = _ref.scaleY,\n      scaleY = _ref$scaleY === void 0 ? 1 : _ref$scaleY,\n      _ref$translateX = _ref.translateX,\n      translateX = _ref$translateX === void 0 ? 0 : _ref$translateX,\n      _ref$translateY = _ref.translateY,\n      translateY = _ref$translateY === void 0 ? 0 : _ref$translateY,\n      _ref$skewX = _ref.skewX,\n      skewX = _ref$skewX === void 0 ? 0 : _ref$skewX,\n      _ref$skewY = _ref.skewY,\n      skewY = _ref$skewY === void 0 ? 0 : _ref$skewY;\n  return {\n    scaleX: scaleX,\n    scaleY: scaleY,\n    translateX: translateX,\n    translateY: translateY,\n    skewX: skewX,\n    skewY: skewY\n  };\n}\nexport function inverseMatrix(_ref2) {\n  var scaleX = _ref2.scaleX,\n      scaleY = _ref2.scaleY,\n      translateX = _ref2.translateX,\n      translateY = _ref2.translateY,\n      skewX = _ref2.skewX,\n      skewY = _ref2.skewY;\n  var denominator = scaleX * scaleY - skewY * skewX;\n  return {\n    scaleX: scaleY / denominator,\n    scaleY: scaleX / denominator,\n    translateX: (scaleY * translateX - skewX * translateY) / -denominator,\n    translateY: (skewY * translateX - scaleX * translateY) / denominator,\n    skewX: skewX / -denominator,\n    skewY: skewY / -denominator\n  };\n}\nexport function applyMatrixToPoint(matrix, _ref3) {\n  var x = _ref3.x,\n      y = _ref3.y;\n  return {\n    x: matrix.scaleX * x + matrix.skewX * y + matrix.translateX,\n    y: matrix.skewY * x + matrix.scaleY * y + matrix.translateY\n  };\n}\nexport function applyInverseMatrixToPoint(matrix, _ref4) {\n  var x = _ref4.x,\n      y = _ref4.y;\n  return applyMatrixToPoint(inverseMatrix(matrix), {\n    x: x,\n    y: y\n  });\n}\nexport function scaleMatrix(scaleX, maybeScaleY) {\n  if (maybeScaleY === void 0) {\n    maybeScaleY = undefined;\n  }\n\n  var scaleY = maybeScaleY || scaleX;\n  return createMatrix({\n    scaleX: scaleX,\n    scaleY: scaleY\n  });\n}\nexport function translateMatrix(translateX, translateY) {\n  return createMatrix({\n    translateX: translateX,\n    translateY: translateY\n  });\n}\nexport function multiplyMatrices(matrix1, matrix2) {\n  return {\n    scaleX: matrix1.scaleX * matrix2.scaleX + matrix1.skewX * matrix2.skewY,\n    scaleY: matrix1.skewY * matrix2.skewX + matrix1.scaleY * matrix2.scaleY,\n    translateX: matrix1.scaleX * matrix2.translateX + matrix1.skewX * matrix2.translateY + matrix1.translateX,\n    translateY: matrix1.skewY * matrix2.translateX + matrix1.scaleY * matrix2.translateY + matrix1.translateY,\n    skewX: matrix1.scaleX * matrix2.skewX + matrix1.skewX * matrix2.scaleY,\n    skewY: matrix1.skewY * matrix2.scaleX + matrix1.scaleY * matrix2.skewY\n  };\n}\nexport function composeMatrices() {\n  for (var _len = arguments.length, matrices = new Array(_len), _key = 0; _key < _len; _key++) {\n    matrices[_key] = arguments[_key];\n  }\n\n  switch (matrices.length) {\n    case 0:\n      throw new Error('composeMatrices() requires arguments: was called with no args');\n\n    case 1:\n      return matrices[0];\n\n    case 2:\n      return multiplyMatrices(matrices[0], matrices[1]);\n\n    default:\n      {\n        var matrix1 = matrices[0],\n            matrix2 = matrices[1],\n            restMatrices = matrices.slice(2);\n        var matrix = multiplyMatrices(matrix1, matrix2);\n        return composeMatrices.apply(void 0, [matrix].concat(restMatrices));\n      }\n  }\n}"]},"metadata":{},"sourceType":"module"}