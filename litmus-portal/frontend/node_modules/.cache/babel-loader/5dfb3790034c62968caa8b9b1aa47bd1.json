{"ast":null,"code":"import _toConsumableArray from \"/home/vedant/go/src/github.com/litmus/litmus-portal/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\n\n/* eslint-disable no-unsafe-finally */\n\n/* eslint-disable no-loop-func */\n\n/* eslint-disable no-param-reassign */\nimport YAML from 'yaml';\nimport { v4 as uuidv4 } from 'uuid';\nimport { constants } from '../constants';\n\nvar validateNamespace = function validateNamespace(chaosEngine) {\n  // Condition to check the namespace\n  if (typeof chaosEngine.metadata.namespace === 'object') {\n    // Removes any whitespace in '{{workflow.parameters.adminModeNamespace}}'\n    var namespace = Object.keys(chaosEngine.metadata.namespace)[0].replace(/\\s/g, '');\n    chaosEngine.metadata.namespace = \"{\".concat(namespace, \"}\");\n  }\n};\n\nvar nameextractor = function nameextractor(val) {\n  var embeddedworkflowyamlstring = val;\n  var parsedEmbeddedYaml = YAML.parse(embeddedworkflowyamlstring);\n  var experimentNames = [''];\n  var experimentList = parsedEmbeddedYaml.spec.experiments;\n  experimentList.forEach(function (element) {\n    experimentNames.push(element.name);\n  });\n\n  if (experimentNames.length >= 2) {\n    experimentNames.shift();\n  }\n\n  return experimentNames;\n};\n\nexport var updateEngineName = function updateEngineName(parsedYaml) {\n  var engineInstance = '';\n\n  try {\n    if (parsedYaml.spec !== undefined) {\n      var yamlData = parsedYaml.spec;\n      yamlData.templates.forEach(function (template) {\n        if (template.inputs && template.inputs.artifacts) {\n          template.inputs.artifacts.forEach(function (artifact) {\n            var chaosEngine = YAML.parse(artifact.raw.data);\n            validateNamespace(chaosEngine); // Condition to check for the kind as ChaosEngine\n\n            if (chaosEngine.kind === 'ChaosEngine') {\n              if (chaosEngine.metadata.generateName === undefined) {\n                chaosEngine.metadata['generateName'] = chaosEngine.metadata.name;\n                delete chaosEngine.metadata.name;\n              }\n\n              chaosEngine.metadata['labels'] = {\n                instance_id: uuidv4()\n              };\n              validateNamespace(chaosEngine); // Edge Case: Condition to check the appns\n              // Required because while parsing the chaos engine\n              // '{{workflow.parameters.adminModeNamespace}}' changes to a JSON object\n\n              if (chaosEngine.spec.appinfo && chaosEngine.spec.appinfo.appns) if (typeof chaosEngine.spec.appinfo.appns === 'object') {\n                // Removes any whitespace in '{{workflow.parameters.adminModeNamespace}}'\n                var appns = Object.keys(chaosEngine.spec.appinfo.appns)[0].replace(/\\s/g, '');\n                chaosEngine.spec.appinfo.appns = \"{\".concat(appns, \"}\");\n              }\n              engineInstance += \"\".concat(chaosEngine.metadata.labels['instance_id'], \", \");\n            } // Update the artifact in template\n\n\n            var artifactData = artifact;\n            artifactData.raw.data = YAML.stringify(chaosEngine);\n          });\n        }\n\n        if (template.name.includes('revert-')) {\n          // Update the args in revert chaos template\n          var revertTemplate = template;\n          revertTemplate.container.args[0] = \"kubectl delete chaosengine -l 'instance_id in (\".concat(engineInstance, \")' -n {{workflow.parameters.adminModeNamespace}} \");\n        }\n      });\n    }\n\n    return YAML.stringify(parsedYaml);\n  } catch (err) {\n    console.error(err);\n    return YAML.stringify(parsedYaml);\n  }\n};\nexport var updateWorkflowNameLabel = function updateWorkflowNameLabel(parsedYaml, workflowName) {\n  try {\n    if (parsedYaml.spec !== undefined) {\n      var yamlData = parsedYaml.kind === constants.workflow ? parsedYaml.spec : parsedYaml.spec.workflowSpec;\n      yamlData.templates.forEach(function (template) {\n        if (template.inputs && template.inputs.artifacts) {\n          template.inputs.artifacts.forEach(function (artifact) {\n            var chaosEngine = YAML.parse(artifact.raw.data);\n            validateNamespace(chaosEngine); // Condition to check for the kind as ChaosEngine\n\n            if (chaosEngine.kind === 'ChaosEngine') {\n              if (chaosEngine.metadata.labels !== undefined) {\n                chaosEngine.metadata.labels['workflow_name'] = workflowName;\n              } else {\n                chaosEngine.metadata['labels'] = {\n                  workflow_name: workflowName\n                };\n              }\n\n              validateNamespace(chaosEngine); // Edge Case: Condition to check the appns\n              // Required because while parsing the chaos engine\n              // '{{workflow.parameters.adminModeNamespace}}' changes to a JSON object\n\n              if (chaosEngine.spec.appinfo && chaosEngine.spec.appinfo.appns) if (typeof chaosEngine.spec.appinfo.appns === 'object') {\n                // Removes any whitespace in '{{workflow.parameters.adminModeNamespace}}'\n                var appns = Object.keys(chaosEngine.spec.appinfo.appns)[0].replace(/\\s/g, '');\n                chaosEngine.spec.appinfo.appns = \"{\".concat(appns, \"}\");\n              }\n            } // Update the artifact in template\n\n\n            var artifactData = artifact;\n            artifactData.raw.data = YAML.stringify(chaosEngine);\n          });\n        }\n      });\n    }\n\n    return parsedYaml;\n  } catch (err) {\n    console.error(err);\n    return parsedYaml;\n  }\n};\n\nvar parsed = function parsed(yaml) {\n  var file = yaml;\n\n  if (file === 'error') {\n    var _testNames = ['none'];\n    return _testNames;\n  }\n\n  var testNames = [];\n\n  try {\n    var parsedYaml = YAML.parse(file);\n\n    try {\n      if (parsedYaml.kind === 'CronWorkflow') {\n        var totalSteps = parsedYaml.spec.workflowSpec.templates.length - 1; // Total Steps in CronWorkflow\n\n        for (var i = 0; i < totalSteps; i++) {\n          var TemplateElement = YAML.stringify(parsedYaml.spec.workflowSpec.templates[1 + i]); // Accessing Current Step\n\n          if (TemplateElement.match(/kind: ChaosEngine/g)) {\n            var _testNames2;\n\n            // Checking if current step contains \"kind: ChaosEngine\"\n            var embeddedYaml = parsedYaml.spec.workflowSpec.templates[1 + i].inputs.artifacts[0].raw.data;\n            var testName = nameextractor(embeddedYaml);\n\n            (_testNames2 = testNames).push.apply(_testNames2, _toConsumableArray(testName));\n          }\n        }\n      } else {\n        var _totalSteps = parsedYaml.spec.templates.length - 1; // Total Steps in Workflow\n\n\n        for (var _i = 0; _i < _totalSteps; _i++) {\n          var _TemplateElement = YAML.stringify(parsedYaml.spec.templates[1 + _i]); // Accessing Current Step\n\n\n          if (_TemplateElement.match(/kind: ChaosEngine/g)) {\n            var _testNames3;\n\n            // Checking if current step contains \"kind: ChaosEngine\"\n            var _embeddedYaml = parsedYaml.spec.templates[1 + _i].inputs.artifacts[0].raw.data;\n\n            var _testName = nameextractor(_embeddedYaml);\n\n            (_testNames3 = testNames).push.apply(_testNames3, _toConsumableArray(_testName));\n          }\n        }\n      }\n    } catch (err) {\n      testNames = [];\n    } finally {\n      return testNames;\n    }\n  } catch (err) {\n    testNames = [];\n    return testNames;\n  }\n};\n\nexport var fetchWorkflowNameFromManifest = function fetchWorkflowNameFromManifest(manifest) {\n  return YAML.parse(manifest).metadata.name;\n};\nexport var getWorkflowParameter = function getWorkflowParameter(parameterString) {\n  return parameterString.substring(1, parameterString.length - 1).replace(/^\\s+|\\s+$/gm, '').split('.')[2];\n};\nexport var generateChaosQuery = function generateChaosQuery(chaosQueryStringTemplate, engineName, namespace) {\n  var queryStringWithEngineName = chaosQueryStringTemplate.replaceAll('#{}', engineName);\n  return queryStringWithEngineName.replaceAll('*{}', namespace);\n};\nexport var updateNamespace = function updateNamespace(manifest, namespace) {\n  var updatedManifest = YAML.parse(manifest);\n  updatedManifest.metadata.namespace = namespace;\n  if (updatedManifest.kind.toLowerCase() === 'workflow') updatedManifest.spec.arguments.parameters.forEach(function (parameter, index) {\n    if (parameter.name === constants.adminMode) {\n      updatedManifest.spec.arguments.parameters[index].value = namespace;\n    }\n  });\n  if (updatedManifest.kind.toLowerCase() === 'cronworkflow') updatedManifest.spec.workflowSpec.arguments.parameters.forEach(function (parameter, index) {\n    if (parameter.name === constants.adminMode) {\n      updatedManifest.spec.workflowSpec.arguments.parameters[index].value = namespace;\n    }\n  });\n  return updatedManifest;\n}; // This is a utility function for extracting embedded\n// yaml as a string for chaosengine with provided name\n\nexport var stepEmbeddedYAMLExtractor = function stepEmbeddedYAMLExtractor(manifest, stepName) {\n  var file = manifest;\n  var embeddedYaml = '';\n\n  try {\n    var parsedYaml = YAML.parse(file);\n\n    try {\n      if (parsedYaml.kind === 'CronWorkflow') {\n        var totalSteps = parsedYaml.spec.workflowSpec.templates.length - 1; // Total Steps in CronWorkflow\n\n        for (var i = 0; i < totalSteps; i++) {\n          if (parsedYaml.spec.workflowSpec.templates[1 + i].name === stepName) {\n            embeddedYaml = parsedYaml.spec.workflowSpec.templates[1 + i].inputs.artifacts[0].raw.data;\n            break;\n          }\n        }\n      } else {\n        var _totalSteps2 = parsedYaml.spec.templates.length - 1; // Total Steps in Workflow\n\n\n        for (var _i2 = 0; _i2 < _totalSteps2; _i2++) {\n          if (parsedYaml.spec.templates[1 + _i2].name === stepName) {\n            embeddedYaml = parsedYaml.spec.templates[1 + _i2].inputs.artifacts[0].raw.data;\n            break;\n          }\n        }\n      }\n    } catch (err) {\n      embeddedYaml = '';\n    } finally {\n      return embeddedYaml;\n    }\n  } catch (err) {\n    embeddedYaml = '';\n    return embeddedYaml;\n  }\n};\nexport default parsed;\n/**\n * updateManifestImage updates the image registry of the workflow manifest\n */\n\nexport var updateManifestImage = function updateManifestImage(parsedYaml, registryData) {\n  if (parsedYaml.spec !== undefined) {\n    if (parsedYaml.kind.toLowerCase() === 'workflow') {\n      if (registryData.image_registry_type.toLocaleLowerCase() === 'private') {\n        parsedYaml.spec['imagePullSecrets'] = [{\n          name: registryData.secret_name\n        }];\n      }\n\n      parsedYaml.spec.templates.forEach(function (template) {\n        if (template.container) {\n          if (registryData.image_repo_name !== constants.litmus) {\n            var imageData = template.container.image.split('/');\n            var imageName = imageData[imageData.length - 1];\n            template.container.image = \"\".concat(registryData.image_registry_name, \"/\").concat(registryData.image_repo_name, \"/\").concat(imageName);\n          } else {\n            var _imageData = template.container.image.split('/');\n\n            var _imageName = _imageData[_imageData.length - 1];\n            template.container.image = \"\".concat(constants.litmus, \"/\").concat(_imageName);\n          }\n        }\n      });\n    }\n\n    if (parsedYaml.kind.toLowerCase() === 'cronworkflow') {\n      if (registryData.image_registry_type.toLocaleLowerCase() === 'private') {\n        parsedYaml.spec.workflowSpec['imagePullSecrets'] = [{\n          name: registryData.secret_name\n        }];\n      }\n\n      parsedYaml.spec.workflowSpec.templates.forEach(function (template) {\n        if (template.container) {\n          if (registryData.image_repo_name !== constants.litmus) {\n            var imageData = template.container.image.split('/');\n            var imageName = imageData[imageData.length - 1];\n            template.container.image = \"\".concat(registryData.image_registry_name, \"/\").concat(registryData.image_repo_name, \"/\").concat(imageName);\n          } else {\n            var _imageData2 = template.container.image.split('/');\n\n            var _imageName2 = _imageData2[_imageData2.length - 1];\n            template.container.image = \"\".concat(constants.litmus, \"/\").concat(_imageName2);\n          }\n        }\n      });\n    }\n  }\n\n  return YAML.stringify(parsedYaml);\n};","map":{"version":3,"sources":["/home/vedant/go/src/github.com/litmus/litmus-portal/frontend/src/utils/yamlUtils.ts"],"names":["YAML","v4","uuidv4","constants","validateNamespace","chaosEngine","metadata","namespace","Object","keys","replace","nameextractor","val","embeddedworkflowyamlstring","parsedEmbeddedYaml","parse","experimentNames","experimentList","spec","experiments","forEach","element","push","name","length","shift","updateEngineName","parsedYaml","engineInstance","undefined","yamlData","templates","template","inputs","artifacts","artifact","raw","data","kind","generateName","instance_id","appinfo","appns","labels","artifactData","stringify","includes","revertTemplate","container","args","err","console","error","updateWorkflowNameLabel","workflowName","workflow","workflowSpec","workflow_name","parsed","yaml","file","testNames","totalSteps","i","TemplateElement","match","embeddedYaml","testName","fetchWorkflowNameFromManifest","manifest","getWorkflowParameter","parameterString","substring","split","generateChaosQuery","chaosQueryStringTemplate","engineName","queryStringWithEngineName","replaceAll","updateNamespace","updatedManifest","toLowerCase","arguments","parameters","parameter","index","adminMode","value","stepEmbeddedYAMLExtractor","stepName","updateManifestImage","registryData","image_registry_type","toLocaleLowerCase","secret_name","image_repo_name","litmus","imageData","image","imageName","image_registry_name"],"mappings":"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","sourcesContent":["/* eslint-disable no-unsafe-finally */\n/* eslint-disable no-loop-func */\n/* eslint-disable no-param-reassign */\nimport YAML from 'yaml';\nimport { v4 as uuidv4 } from 'uuid';\nimport { constants } from '../constants';\nimport { ImageRegistryInfo } from '../models/redux/image_registry';\n\nconst validateNamespace = (chaosEngine: any) => {\n  // Condition to check the namespace\n  if (typeof chaosEngine.metadata.namespace === 'object') {\n    // Removes any whitespace in '{{workflow.parameters.adminModeNamespace}}'\n    const namespace = Object.keys(chaosEngine.metadata.namespace)[0].replace(\n      /\\s/g,\n      ''\n    );\n    chaosEngine.metadata.namespace = `{${namespace}}`;\n  }\n};\nconst nameextractor = (val: any) => {\n  const embeddedworkflowyamlstring = val;\n  const parsedEmbeddedYaml = YAML.parse(embeddedworkflowyamlstring as string);\n  const experimentNames = [''];\n  const experimentList = parsedEmbeddedYaml.spec.experiments;\n\n  (experimentList as any).forEach((element: any) => {\n    experimentNames.push(element.name);\n  });\n\n  if (experimentNames.length >= 2) {\n    experimentNames.shift();\n  }\n\n  return experimentNames;\n};\n\nexport const updateEngineName = (parsedYaml: any) => {\n  let engineInstance: string = '';\n  try {\n    if (parsedYaml.spec !== undefined) {\n      const yamlData = parsedYaml.spec;\n      yamlData.templates.forEach((template: any) => {\n        if (template.inputs && template.inputs.artifacts) {\n          template.inputs.artifacts.forEach((artifact: any) => {\n            const chaosEngine = YAML.parse(artifact.raw.data);\n            validateNamespace(chaosEngine);\n            // Condition to check for the kind as ChaosEngine\n            if (chaosEngine.kind === 'ChaosEngine') {\n              if (chaosEngine.metadata.generateName === undefined) {\n                chaosEngine.metadata['generateName'] =\n                  chaosEngine.metadata.name;\n                delete chaosEngine.metadata.name;\n              }\n              chaosEngine.metadata['labels'] = {\n                instance_id: uuidv4(),\n              };\n              validateNamespace(chaosEngine);\n\n              // Edge Case: Condition to check the appns\n              // Required because while parsing the chaos engine\n              // '{{workflow.parameters.adminModeNamespace}}' changes to a JSON object\n              if (chaosEngine.spec.appinfo && chaosEngine.spec.appinfo.appns)\n                if (typeof chaosEngine.spec.appinfo.appns === 'object') {\n                  // Removes any whitespace in '{{workflow.parameters.adminModeNamespace}}'\n                  const appns = Object.keys(\n                    chaosEngine.spec.appinfo.appns\n                  )[0].replace(/\\s/g, '');\n                  chaosEngine.spec.appinfo.appns = `{${appns}}`;\n                }\n              engineInstance += `${chaosEngine.metadata.labels['instance_id']}, `;\n            }\n            // Update the artifact in template\n            const artifactData = artifact;\n            artifactData.raw.data = YAML.stringify(chaosEngine);\n          });\n        }\n        if (template.name.includes('revert-')) {\n          // Update the args in revert chaos template\n          const revertTemplate = template;\n          revertTemplate.container.args[0] = `kubectl delete chaosengine -l 'instance_id in (${engineInstance})' -n {{workflow.parameters.adminModeNamespace}} `;\n        }\n      });\n    }\n    return YAML.stringify(parsedYaml);\n  } catch (err) {\n    console.error(err);\n    return YAML.stringify(parsedYaml);\n  }\n};\n\nexport const updateWorkflowNameLabel = (\n  parsedYaml: any,\n  workflowName: string\n) => {\n  try {\n    if (parsedYaml.spec !== undefined) {\n      const yamlData =\n        parsedYaml.kind === constants.workflow\n          ? parsedYaml.spec\n          : parsedYaml.spec.workflowSpec;\n      yamlData.templates.forEach((template: any) => {\n        if (template.inputs && template.inputs.artifacts) {\n          template.inputs.artifacts.forEach((artifact: any) => {\n            const chaosEngine = YAML.parse(artifact.raw.data);\n            validateNamespace(chaosEngine);\n            // Condition to check for the kind as ChaosEngine\n            if (chaosEngine.kind === 'ChaosEngine') {\n              if (chaosEngine.metadata.labels !== undefined) {\n                chaosEngine.metadata.labels['workflow_name'] = workflowName;\n              } else {\n                chaosEngine.metadata['labels'] = {\n                  workflow_name: workflowName,\n                };\n              }\n\n              validateNamespace(chaosEngine);\n\n              // Edge Case: Condition to check the appns\n              // Required because while parsing the chaos engine\n              // '{{workflow.parameters.adminModeNamespace}}' changes to a JSON object\n              if (chaosEngine.spec.appinfo && chaosEngine.spec.appinfo.appns)\n                if (typeof chaosEngine.spec.appinfo.appns === 'object') {\n                  // Removes any whitespace in '{{workflow.parameters.adminModeNamespace}}'\n                  const appns = Object.keys(\n                    chaosEngine.spec.appinfo.appns\n                  )[0].replace(/\\s/g, '');\n                  chaosEngine.spec.appinfo.appns = `{${appns}}`;\n                }\n            }\n            // Update the artifact in template\n            const artifactData = artifact;\n            artifactData.raw.data = YAML.stringify(chaosEngine);\n          });\n        }\n      });\n    }\n    return parsedYaml;\n  } catch (err) {\n    console.error(err);\n    return parsedYaml;\n  }\n};\n\nconst parsed = (yaml: string) => {\n  const file = yaml;\n  if (file === 'error') {\n    const testNames = ['none'];\n    return testNames;\n  }\n  let testNames: string[] = [];\n  try {\n    const parsedYaml = YAML.parse(file as string);\n    try {\n      if (parsedYaml.kind === 'CronWorkflow') {\n        const totalSteps = parsedYaml.spec.workflowSpec.templates.length - 1; // Total Steps in CronWorkflow\n        for (let i = 0; i < totalSteps; i++) {\n          const TemplateElement = YAML.stringify(\n            parsedYaml.spec.workflowSpec.templates[1 + i]\n          ); // Accessing Current Step\n          if (TemplateElement.match(/kind: ChaosEngine/g)) {\n            // Checking if current step contains \"kind: ChaosEngine\"\n            const embeddedYaml =\n              parsedYaml.spec.workflowSpec.templates[1 + i].inputs.artifacts[0]\n                .raw.data;\n            const testName = nameextractor(embeddedYaml);\n            testNames.push(...testName);\n          }\n        }\n      } else {\n        const totalSteps = parsedYaml.spec.templates.length - 1; // Total Steps in Workflow\n        for (let i = 0; i < totalSteps; i++) {\n          const TemplateElement = YAML.stringify(\n            parsedYaml.spec.templates[1 + i]\n          ); // Accessing Current Step\n          if (TemplateElement.match(/kind: ChaosEngine/g)) {\n            // Checking if current step contains \"kind: ChaosEngine\"\n            const embeddedYaml =\n              parsedYaml.spec.templates[1 + i].inputs.artifacts[0].raw.data;\n            const testName = nameextractor(embeddedYaml);\n            testNames.push(...testName);\n          }\n        }\n      }\n    } catch (err) {\n      testNames = [];\n    } finally {\n      return testNames;\n    }\n  } catch (err) {\n    testNames = [];\n    return testNames;\n  }\n};\n\nexport const fetchWorkflowNameFromManifest = (manifest: string) => {\n  return YAML.parse(manifest).metadata.name;\n};\n\nexport const getWorkflowParameter = (parameterString: string) => {\n  return parameterString\n    .substring(1, parameterString.length - 1)\n    .replace(/^\\s+|\\s+$/gm, '')\n    .split('.')[2];\n};\n\nexport const generateChaosQuery = (\n  chaosQueryStringTemplate: string,\n  engineName: string,\n  namespace: string\n) => {\n  const queryStringWithEngineName: string = chaosQueryStringTemplate.replaceAll(\n    '#{}',\n    engineName\n  );\n  return queryStringWithEngineName.replaceAll('*{}', namespace);\n};\n\nexport const updateNamespace = (manifest: string, namespace: string) => {\n  const updatedManifest = YAML.parse(manifest);\n  updatedManifest.metadata.namespace = namespace;\n  if (updatedManifest.kind.toLowerCase() === 'workflow')\n    updatedManifest.spec.arguments.parameters.forEach(\n      (parameter: any, index: number) => {\n        if (parameter.name === constants.adminMode) {\n          updatedManifest.spec.arguments.parameters[index].value = namespace;\n        }\n      }\n    );\n  if (updatedManifest.kind.toLowerCase() === 'cronworkflow')\n    updatedManifest.spec.workflowSpec.arguments.parameters.forEach(\n      (parameter: any, index: number) => {\n        if (parameter.name === constants.adminMode) {\n          updatedManifest.spec.workflowSpec.arguments.parameters[index].value =\n            namespace;\n        }\n      }\n    );\n  return updatedManifest;\n};\n\n// This is a utility function for extracting embedded\n// yaml as a string for chaosengine with provided name\nexport const stepEmbeddedYAMLExtractor = (\n  manifest: string,\n  stepName: string\n) => {\n  const file = manifest;\n  let embeddedYaml = '';\n  try {\n    const parsedYaml = YAML.parse(file as string);\n    try {\n      if (parsedYaml.kind === 'CronWorkflow') {\n        const totalSteps = parsedYaml.spec.workflowSpec.templates.length - 1; // Total Steps in CronWorkflow\n        for (let i = 0; i < totalSteps; i++) {\n          if (parsedYaml.spec.workflowSpec.templates[1 + i].name === stepName) {\n            embeddedYaml =\n              parsedYaml.spec.workflowSpec.templates[1 + i].inputs.artifacts[0]\n                .raw.data;\n            break;\n          }\n        }\n      } else {\n        const totalSteps = parsedYaml.spec.templates.length - 1; // Total Steps in Workflow\n        for (let i = 0; i < totalSteps; i++) {\n          if (parsedYaml.spec.templates[1 + i].name === stepName) {\n            embeddedYaml =\n              parsedYaml.spec.templates[1 + i].inputs.artifacts[0].raw.data;\n            break;\n          }\n        }\n      }\n    } catch (err) {\n      embeddedYaml = '';\n    } finally {\n      return embeddedYaml;\n    }\n  } catch (err) {\n    embeddedYaml = '';\n    return embeddedYaml;\n  }\n};\n\nexport default parsed;\n\n/**\n * updateManifestImage updates the image registry of the workflow manifest\n */\nexport const updateManifestImage = (\n  parsedYaml: any,\n  registryData: ImageRegistryInfo\n) => {\n  if (parsedYaml.spec !== undefined) {\n    if (parsedYaml.kind.toLowerCase() === 'workflow') {\n      if (registryData.image_registry_type.toLocaleLowerCase() === 'private') {\n        parsedYaml.spec['imagePullSecrets'] = [\n          {\n            name: registryData.secret_name,\n          },\n        ];\n      }\n      parsedYaml.spec.templates.forEach((template: any) => {\n        if (template.container) {\n          if (registryData.image_repo_name !== constants.litmus) {\n            const imageData = template.container.image.split('/');\n            const imageName = imageData[imageData.length - 1];\n            template.container.image = `${registryData.image_registry_name}/${registryData.image_repo_name}/${imageName}`;\n          } else {\n            const imageData = template.container.image.split('/');\n            const imageName = imageData[imageData.length - 1];\n            template.container.image = `${constants.litmus}/${imageName}`;\n          }\n        }\n      });\n    }\n    if (parsedYaml.kind.toLowerCase() === 'cronworkflow') {\n      if (registryData.image_registry_type.toLocaleLowerCase() === 'private') {\n        parsedYaml.spec.workflowSpec['imagePullSecrets'] = [\n          {\n            name: registryData.secret_name,\n          },\n        ];\n      }\n      parsedYaml.spec.workflowSpec.templates.forEach((template: any) => {\n        if (template.container) {\n          if (registryData.image_repo_name !== constants.litmus) {\n            const imageData = template.container.image.split('/');\n            const imageName = imageData[imageData.length - 1];\n            template.container.image = `${registryData.image_registry_name}/${registryData.image_repo_name}/${imageName}`;\n          } else {\n            const imageData = template.container.image.split('/');\n            const imageName = imageData[imageData.length - 1];\n            template.container.image = `${constants.litmus}/${imageName}`;\n          }\n        }\n      });\n    }\n  }\n  return YAML.stringify(parsedYaml);\n};\n"]},"metadata":{},"sourceType":"module"}