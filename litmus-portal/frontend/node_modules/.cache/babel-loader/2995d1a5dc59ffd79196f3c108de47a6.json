{"ast":null,"code":"import _defineProperty from\"/home/vedant/go/src/github.com/litmus/litmus-portal/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/defineProperty\";import _objectSpread from\"/home/vedant/go/src/github.com/litmus/litmus-portal/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2\";import _toConsumableArray from\"/home/vedant/go/src/github.com/litmus/litmus-portal/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";import _slicedToArray from\"/home/vedant/go/src/github.com/litmus/litmus-portal/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";/**\n * Function for reordering the result\n */export var reorder=function reorder(list,startIndex,endIndex){var result=Array.from(list);var _result$splice=result.splice(startIndex,1),_result$splice2=_slicedToArray(_result$splice,1),removed=_result$splice2[0];result.splice(endIndex,0,removed);return result;};export var reorderSteps=function reorderSteps(steps,source,destination){var _objectSpread3;var current=_toConsumableArray(steps[source.droppableId]);var next=_toConsumableArray(steps[destination.droppableId]);var target=current[source.index];/**\n   * Moving data to same list\n   */if(source.droppableId===destination.droppableId){var reordered=reorder(current,source.index,destination.index);return _objectSpread(_objectSpread({},steps),{},_defineProperty({},source.droppableId,reordered));}/**\n   * Moving to different list\n   */current.splice(source.index,1);// Remove from original list\nnext.splice(destination.index,0,target);// Insert into the new list\nreturn _objectSpread(_objectSpread({},steps),{},(_objectSpread3={},_defineProperty(_objectSpread3,source.droppableId,current),_defineProperty(_objectSpread3,destination.droppableId,next),_objectSpread3));};","map":{"version":3,"sources":["/home/vedant/go/src/github.com/litmus/litmus-portal/frontend/src/views/CreateWorkflow/TuneWorkflow/WorkflowSequence/reorder.ts"],"names":["reorder","list","startIndex","endIndex","result","Array","from","splice","removed","reorderSteps","steps","source","destination","current","droppableId","next","target","index","reordered"],"mappings":"qtBAWA;AACA;AACA,GACA,MAAO,IAAMA,CAAAA,OAAO,CAAG,QAAVA,CAAAA,OAAU,CACrBC,IADqB,CAErBC,UAFqB,CAGrBC,QAHqB,CAID,CACpB,GAAMC,CAAAA,MAAM,CAAGC,KAAK,CAACC,IAAN,CAAWL,IAAX,CAAf,CACA,mBAAkBG,MAAM,CAACG,MAAP,CAAcL,UAAd,CAA0B,CAA1B,CAAlB,kDAAOM,OAAP,oBACAJ,MAAM,CAACG,MAAP,CAAcJ,QAAd,CAAwB,CAAxB,CAA2BK,OAA3B,EAEA,MAAOJ,CAAAA,MAAP,CACD,CAVM,CAYP,MAAO,IAAMK,CAAAA,YAAY,CAAG,QAAfA,CAAAA,YAAe,CAC1BC,KAD0B,CAE1BC,MAF0B,CAG1BC,WAH0B,CAIvB,oBACH,GAAMC,CAAAA,OAAO,oBAAOH,KAAK,CAACC,MAAM,CAACG,WAAR,CAAZ,CAAb,CACA,GAAMC,CAAAA,IAAI,oBAAOL,KAAK,CAACE,WAAW,CAACE,WAAb,CAAZ,CAAV,CACA,GAAME,CAAAA,MAAM,CAAGH,OAAO,CAACF,MAAM,CAACM,KAAR,CAAtB,CACA;AACF;AACA,KACE,GAAIN,MAAM,CAACG,WAAP,GAAuBF,WAAW,CAACE,WAAvC,CAAoD,CAClD,GAAMI,CAAAA,SAAS,CAAGlB,OAAO,CAACa,OAAD,CAAUF,MAAM,CAACM,KAAjB,CAAwBL,WAAW,CAACK,KAApC,CAAzB,CACA,sCACKP,KADL,wBAEGC,MAAM,CAACG,WAFV,CAEwBI,SAFxB,GAID,CAED;AACF;AACA,KACEL,OAAO,CAACN,MAAR,CAAeI,MAAM,CAACM,KAAtB,CAA6B,CAA7B,EAAiC;AACjCF,IAAI,CAACR,MAAL,CAAYK,WAAW,CAACK,KAAxB,CAA+B,CAA/B,CAAkCD,MAAlC,EAA2C;AAE3C,sCACKN,KADL,uDAEGC,MAAM,CAACG,WAFV,CAEwBD,OAFxB,iCAGGD,WAAW,CAACE,WAHf,CAG6BC,IAH7B,mBAKD,CA9BM","sourcesContent":["import { DraggableLocation } from 'react-beautiful-dnd';\n\ninterface ManifestSteps {\n  name: string;\n  template: string;\n}\n\ninterface StepType {\n  [key: string]: ManifestSteps[];\n}\n\n/**\n * Function for reordering the result\n */\nexport const reorder = (\n  list: ManifestSteps[],\n  startIndex: number,\n  endIndex: number\n): ManifestSteps[] => {\n  const result = Array.from(list);\n  const [removed] = result.splice(startIndex, 1);\n  result.splice(endIndex, 0, removed);\n\n  return result;\n};\n\nexport const reorderSteps = (\n  steps: StepType,\n  source: DraggableLocation,\n  destination: DraggableLocation\n) => {\n  const current = [...steps[source.droppableId]];\n  const next = [...steps[destination.droppableId]];\n  const target = current[source.index];\n  /**\n   * Moving data to same list\n   */\n  if (source.droppableId === destination.droppableId) {\n    const reordered = reorder(current, source.index, destination.index);\n    return {\n      ...steps,\n      [source.droppableId]: reordered,\n    };\n  }\n\n  /**\n   * Moving to different list\n   */\n  current.splice(source.index, 1); // Remove from original list\n  next.splice(destination.index, 0, target); // Insert into the new list\n\n  return {\n    ...steps,\n    [source.droppableId]: current,\n    [destination.droppableId]: next,\n  };\n};\n"]},"metadata":{},"sourceType":"module"}