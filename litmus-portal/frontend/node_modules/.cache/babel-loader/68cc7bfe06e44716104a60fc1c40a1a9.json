{"ast":null,"code":"import YAML from'yaml';var steps;export var extractSteps=function extractSteps(isCustom,crd){if(isCustom){// If Custom YAML is provided then save the experiments Serially\nvar parsedYaml=YAML.parse(crd);var customYAMLExtraction=function customYAMLExtraction(template){steps=template.steps&&template.steps;};if(parsedYaml.kind==='Workflow'){customYAMLExtraction(parsedYaml.spec.templates[0]);}else if(parsedYaml.kind==='CronWorkflow'){customYAMLExtraction(parsedYaml.spec.workflowSpec.templates[0]);}}else{// Save the Pre-defined experiments Serial/Parallel\nvar _parsedYaml=YAML.parse(crd);var preDefinedExtraction=function preDefinedExtraction(template){// Extracting Run Chaos Steps and appending to the array\nif(template.name==='argowf-chaos'&&template.steps[1][0].name==='run-chaos'){// Adding install-experiment step\nsteps.push([{name:template.steps[0][0].name,template:template.steps[0][0].name}]);// Serialized Steps\n_parsedYaml.spec.templates.forEach(function(template){if(template.name==='run-chaos'){template.inputs.artifacts.forEach(function(artifact){var chaosEngine=YAML.parse(artifact.raw.data);if(chaosEngine.kind==='ChaosEngine'){steps.push([{name:chaosEngine.metadata.name,template:chaosEngine.metadata.template}]);}});}});// Adding revert-chaos step\ntemplate.steps.forEach(function(step){if(step[0].name==='revert-chaos'){steps.push([{name:step[0].name,template:step[0].name}]);}});}else if(template.name==='argowf-chaos'&&template.steps[1][0].name!=='run-chaos'){// Nested Steps\nsteps=template.steps;}};steps=[];if(_parsedYaml.kind==='Workflow'){_parsedYaml.spec.templates.forEach(function(template){return preDefinedExtraction(template);});}else if(_parsedYaml.kind==='CronWorkflow'){_parsedYaml.spec.workflowSpec.templates.forEach(function(template){return preDefinedExtraction(template);});}}return steps;};","map":{"version":3,"sources":["/home/vedant/go/src/github.com/litmus/litmus-portal/frontend/src/views/CreateWorkflow/TuneWorkflow/ExtractSteps.ts"],"names":["YAML","steps","extractSteps","isCustom","crd","parsedYaml","parse","customYAMLExtraction","template","kind","spec","templates","workflowSpec","preDefinedExtraction","name","push","forEach","inputs","artifacts","artifact","chaosEngine","raw","data","metadata","step"],"mappings":"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","sourcesContent":["import YAML from 'yaml';\nimport { Steps } from '../../../models/chaosWorkflowYaml';\n\nlet steps: Steps[][];\n\nexport const extractSteps = (isCustom: boolean, crd: string) => {\n  if (isCustom) {\n    // If Custom YAML is provided then save the experiments Serially\n    const parsedYaml = YAML.parse(crd);\n\n    const customYAMLExtraction = (template: any) => {\n      steps = template.steps && (template.steps as Steps[][]);\n    };\n\n    if (parsedYaml.kind === 'Workflow') {\n      customYAMLExtraction(parsedYaml.spec.templates[0]);\n    } else if (parsedYaml.kind === 'CronWorkflow') {\n      customYAMLExtraction(parsedYaml.spec.workflowSpec.templates[0]);\n    }\n  } else {\n    // Save the Pre-defined experiments Serial/Parallel\n    const parsedYaml = YAML.parse(crd);\n\n    const preDefinedExtraction = (template: any) => {\n      // Extracting Run Chaos Steps and appending to the array\n      if (\n        template.name === 'argowf-chaos' &&\n        template.steps[1][0].name === 'run-chaos'\n      ) {\n        // Adding install-experiment step\n        steps.push([\n          {\n            name: template.steps[0][0].name,\n            template: template.steps[0][0].name,\n          },\n        ]);\n\n        // Serialized Steps\n        parsedYaml.spec.templates.forEach((template: any) => {\n          if (template.name === 'run-chaos') {\n            template.inputs.artifacts.forEach((artifact: any) => {\n              const chaosEngine = YAML.parse(artifact.raw.data);\n              if (chaosEngine.kind === 'ChaosEngine') {\n                steps.push([\n                  {\n                    name: chaosEngine.metadata.name,\n                    template: chaosEngine.metadata.template,\n                  },\n                ]);\n              }\n            });\n          }\n        });\n\n        // Adding revert-chaos step\n        template.steps.forEach((step: any) => {\n          if (step[0].name === 'revert-chaos') {\n            steps.push([\n              {\n                name: step[0].name,\n                template: step[0].name,\n              },\n            ]);\n          }\n        });\n      } else if (\n        template.name === 'argowf-chaos' &&\n        template.steps[1][0].name !== 'run-chaos'\n      ) {\n        // Nested Steps\n        steps = template.steps as Steps[][];\n      }\n    };\n\n    steps = [];\n    if (parsedYaml.kind === 'Workflow') {\n      parsedYaml.spec.templates.forEach((template: any) =>\n        preDefinedExtraction(template)\n      );\n    } else if (parsedYaml.kind === 'CronWorkflow') {\n      parsedYaml.spec.workflowSpec.templates.forEach((template: any) =>\n        preDefinedExtraction(template)\n      );\n    }\n  }\n  return steps;\n};\n"]},"metadata":{},"sourceType":"module"}