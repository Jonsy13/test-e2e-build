{"ast":null,"code":"export function scaleInvert(scale, value) {\n  // Test if the scale is an ordinalScale or not,\n  // Since an ordinalScale doesn't support invert function.\n  if (!scale.invert) {\n    var _scale$range = scale.range(),\n        start = _scale$range[0],\n        end = _scale$range[1];\n\n    var i = 0; // ordinal should have step\n\n    var width = scale.step() * (end - start) / Math.abs(end - start);\n\n    if (width > 0) {\n      while (value > start + width * (i + 1)) {\n        i += 1;\n      }\n    } else {\n      while (value < start + width * (i + 1)) {\n        i += 1;\n      }\n    }\n\n    return i;\n  }\n\n  return scale.invert(value);\n}\nexport function getDomainFromExtent(scale, start, end, tolerentDelta) {\n  var domain;\n  var invertedStart = scaleInvert(scale, start + (start < end ? -tolerentDelta : tolerentDelta));\n  var invertedEnd = scaleInvert(scale, end + (end < start ? -tolerentDelta : tolerentDelta));\n  var minValue = Math.min(invertedStart, invertedEnd);\n  var maxValue = Math.max(invertedStart, invertedEnd);\n\n  if (scale.invert) {\n    domain = {\n      start: minValue,\n      end: maxValue\n    };\n  } else {\n    var values = [];\n    var scaleDomain = scale.domain();\n\n    for (var i = minValue; i <= maxValue; i += 1) {\n      values.push(scaleDomain[i]);\n    }\n\n    domain = {\n      values: values\n    };\n  }\n\n  return domain;\n}","map":{"version":3,"sources":["/home/vedant/go/src/github.com/litmus/litmus-portal/frontend/node_modules/@visx/brush/esm/utils.js"],"names":["scaleInvert","scale","value","invert","_scale$range","range","start","end","i","width","step","Math","abs","getDomainFromExtent","tolerentDelta","domain","invertedStart","invertedEnd","minValue","min","maxValue","max","values","scaleDomain","push"],"mappings":"AAAA,OAAO,SAASA,WAAT,CAAqBC,KAArB,EAA4BC,KAA5B,EAAmC;AACxC;AACA;AACA,MAAI,CAACD,KAAK,CAACE,MAAX,EAAmB;AACjB,QAAIC,YAAY,GAAGH,KAAK,CAACI,KAAN,EAAnB;AAAA,QACIC,KAAK,GAAGF,YAAY,CAAC,CAAD,CADxB;AAAA,QAEIG,GAAG,GAAGH,YAAY,CAAC,CAAD,CAFtB;;AAIA,QAAII,CAAC,GAAG,CAAR,CALiB,CAKN;;AAEX,QAAIC,KAAK,GAAGR,KAAK,CAACS,IAAN,MAAgBH,GAAG,GAAGD,KAAtB,IAA+BK,IAAI,CAACC,GAAL,CAASL,GAAG,GAAGD,KAAf,CAA3C;;AAEA,QAAIG,KAAK,GAAG,CAAZ,EAAe;AACb,aAAOP,KAAK,GAAGI,KAAK,GAAGG,KAAK,IAAID,CAAC,GAAG,CAAR,CAA5B,EAAwC;AACtCA,QAAAA,CAAC,IAAI,CAAL;AACD;AACF,KAJD,MAIO;AACL,aAAON,KAAK,GAAGI,KAAK,GAAGG,KAAK,IAAID,CAAC,GAAG,CAAR,CAA5B,EAAwC;AACtCA,QAAAA,CAAC,IAAI,CAAL;AACD;AACF;;AAED,WAAOA,CAAP;AACD;;AAED,SAAOP,KAAK,CAACE,MAAN,CAAaD,KAAb,CAAP;AACD;AACD,OAAO,SAASW,mBAAT,CAA6BZ,KAA7B,EAAoCK,KAApC,EAA2CC,GAA3C,EAAgDO,aAAhD,EAA+D;AACpE,MAAIC,MAAJ;AACA,MAAIC,aAAa,GAAGhB,WAAW,CAACC,KAAD,EAAQK,KAAK,IAAIA,KAAK,GAAGC,GAAR,GAAc,CAACO,aAAf,GAA+BA,aAAnC,CAAb,CAA/B;AACA,MAAIG,WAAW,GAAGjB,WAAW,CAACC,KAAD,EAAQM,GAAG,IAAIA,GAAG,GAAGD,KAAN,GAAc,CAACQ,aAAf,GAA+BA,aAAnC,CAAX,CAA7B;AACA,MAAII,QAAQ,GAAGP,IAAI,CAACQ,GAAL,CAASH,aAAT,EAAwBC,WAAxB,CAAf;AACA,MAAIG,QAAQ,GAAGT,IAAI,CAACU,GAAL,CAASL,aAAT,EAAwBC,WAAxB,CAAf;;AAEA,MAAIhB,KAAK,CAACE,MAAV,EAAkB;AAChBY,IAAAA,MAAM,GAAG;AACPT,MAAAA,KAAK,EAAEY,QADA;AAEPX,MAAAA,GAAG,EAAEa;AAFE,KAAT;AAID,GALD,MAKO;AACL,QAAIE,MAAM,GAAG,EAAb;AACA,QAAIC,WAAW,GAAGtB,KAAK,CAACc,MAAN,EAAlB;;AAEA,SAAK,IAAIP,CAAC,GAAGU,QAAb,EAAuBV,CAAC,IAAIY,QAA5B,EAAsCZ,CAAC,IAAI,CAA3C,EAA8C;AAC5Cc,MAAAA,MAAM,CAACE,IAAP,CAAYD,WAAW,CAACf,CAAD,CAAvB;AACD;;AAEDO,IAAAA,MAAM,GAAG;AACPO,MAAAA,MAAM,EAAEA;AADD,KAAT;AAGD;;AAED,SAAOP,MAAP;AACD","sourcesContent":["export function scaleInvert(scale, value) {\n  // Test if the scale is an ordinalScale or not,\n  // Since an ordinalScale doesn't support invert function.\n  if (!scale.invert) {\n    var _scale$range = scale.range(),\n        start = _scale$range[0],\n        end = _scale$range[1];\n\n    var i = 0; // ordinal should have step\n\n    var width = scale.step() * (end - start) / Math.abs(end - start);\n\n    if (width > 0) {\n      while (value > start + width * (i + 1)) {\n        i += 1;\n      }\n    } else {\n      while (value < start + width * (i + 1)) {\n        i += 1;\n      }\n    }\n\n    return i;\n  }\n\n  return scale.invert(value);\n}\nexport function getDomainFromExtent(scale, start, end, tolerentDelta) {\n  var domain;\n  var invertedStart = scaleInvert(scale, start + (start < end ? -tolerentDelta : tolerentDelta));\n  var invertedEnd = scaleInvert(scale, end + (end < start ? -tolerentDelta : tolerentDelta));\n  var minValue = Math.min(invertedStart, invertedEnd);\n  var maxValue = Math.max(invertedStart, invertedEnd);\n\n  if (scale.invert) {\n    domain = {\n      start: minValue,\n      end: maxValue\n    };\n  } else {\n    var values = [];\n    var scaleDomain = scale.domain();\n\n    for (var i = minValue; i <= maxValue; i += 1) {\n      values.push(scaleDomain[i]);\n    }\n\n    domain = {\n      values: values\n    };\n  }\n\n  return domain;\n}"]},"metadata":{},"sourceType":"module"}